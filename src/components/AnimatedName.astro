---
// Props for the AnimatedName component
interface Props {
  name: string;
  fontSize?: string;
  color?: string;
  hoverColor?: string;
}

const {
  name,
  fontSize = "5rem",
  color = "var(--text-color)",
  hoverColor = "var(--accent-color)"
} = Astro.props;
---

<div class="animated-name">
  {Array.from(name).map((letter, index) => (
    <span class="letter" data-index={index}>{letter}</span>
  ))}
</div>

<script>
  // Audio pool system to handle multiple concurrent sounds
  class SoundPool {
    constructor(soundUrl, poolSize = 3) {
      this.sounds = [];
      this.currentIndex = 0;
      this.initialized = false;
      this.poolSize = poolSize;
      this.soundUrl = soundUrl;
    }
    
    // Initialize the pool with multiple audio elements
    init() {
      if (this.initialized) return;
      
      for (let i = 0; i < this.poolSize; i++) {
        const audio = new Audio();
        audio.src = this.soundUrl;
        audio.preload = 'auto';
        
        // Force browser to start loading the audio
        audio.load();
        
        this.sounds.push({
          element: audio,
          ready: true
        });
      }
      
      this.initialized = true;
    }
    
    // Play a sound from the pool
    play(volume = 0.4) {
      if (!this.initialized) this.init();
      
      // Find the next available sound in the pool
      let sound = null;
      let foundReady = false;
      
      // First try to find a ready sound
      for (let i = 0; i < this.sounds.length; i++) {
        const index = (this.currentIndex + i) % this.sounds.length;
        if (this.sounds[index].ready) {
          sound = this.sounds[index];
          this.currentIndex = (index + 1) % this.sounds.length;
          foundReady = true;
          break;
        }
      }
      
      // If no ready sound, force reuse the next one
      if (!foundReady) {
        sound = this.sounds[this.currentIndex];
        this.currentIndex = (this.currentIndex + 1) % this.sounds.length;
      }
      
      // Prepare and play the sound
      const audioElement = sound.element;
      audioElement.volume = volume;
      audioElement.currentTime = 0;
      
      // Mark as not ready, then set it back to ready when ended
      sound.ready = false;
      
      // Use the modern promise-based API with fallback
      const playPromise = audioElement.play();
      
      if (playPromise !== undefined) {
        playPromise
          .then(() => {
            // Set a short timeout to mark the sound as available again
            setTimeout(() => {
              sound.ready = true;
            }, 100); // Short delay to avoid immediate reuse
          })
          .catch(error => {
            console.warn('Audio playback failed:', error);
            sound.ready = true; // Reset on error
          });
      } else {
        // Fallback for browsers without promise support
        audioElement.onended = () => {
          sound.ready = true;
        };
      }
    }
  }
  
  document.addEventListener('DOMContentLoaded', () => {
    console.log('Initializing keyboard sound effects');
    
    // Create sound pools
    const keyDownSoundPool = new SoundPool('/sounds/key-down.mp3', 4);
    const keyUpSoundPool = new SoundPool('/sounds/key-up.mp3', 4);
    
    // Force initialization
    keyDownSoundPool.init();
    keyUpSoundPool.init();
    
    // Initialize interaction on first user interaction to satisfy browser autoplay policies
    function initOnInteraction() {
      // Play a silent sound to unlock audio
      const silentSound = new Audio();
      silentSound.src = '/sounds/key-down.mp3';
      silentSound.volume = 0.001;
      silentSound.play().catch(() => console.log('Silent sound initialization failed, this is normal.'));
      
      // Remove the initialization event now that we've unlocked audio
      document.removeEventListener('click', initOnInteraction);
      document.removeEventListener('touchstart', initOnInteraction);
    }
    
    // Add initialization listeners
    document.addEventListener('click', initOnInteraction, { once: true });
    document.addEventListener('touchstart', initOnInteraction, { once: true });
    
    const letters = document.querySelectorAll('.animated-name .letter');
    
    // Track current state to prevent duplicate events
    const letterStates = new Map();
    letters.forEach(letter => {
      letterStates.set(letter, false); // Not pressed initially
    });
    
    // Add mouseenter/mouseleave events to each letter
    letters.forEach(letter => {
      // Mouseenter - press down the key
      letter.addEventListener('mouseenter', () => {
        if (!letterStates.get(letter)) {
          letter.classList.add('pressed');
          letterStates.set(letter, true);
          
          // Play key down sound with a slight randomization in volume
          const volume = 0.35 + Math.random() * 0.1; // 0.35-0.45 range
          keyDownSoundPool.play(volume);
        }
      });
      
      // Mouseleave - release the key
      letter.addEventListener('mouseleave', () => {
        if (letterStates.get(letter)) {
          letter.classList.remove('pressed');
          letterStates.set(letter, false);
          
          // Play key up sound with a slight randomization in volume
          const volume = 0.25 + Math.random() * 0.1; // 0.25-0.35 range
          keyUpSoundPool.play(volume);
        }
      });
      
      // Also add touchstart/touchend for mobile (optional)
      letter.addEventListener('touchstart', (e) => {
        e.preventDefault(); // Prevent scrolling/zooming
        if (!letterStates.get(letter)) {
          letter.classList.add('pressed');
          letterStates.set(letter, true);
          keyDownSoundPool.play(0.4);
        }
      });
      
      letter.addEventListener('touchend', (e) => {
        e.preventDefault();
        if (letterStates.get(letter)) {
          letter.classList.remove('pressed');
          letterStates.set(letter, false);
          keyUpSoundPool.play(0.3);
        }
      });
    });
    
    // Sequential animation for the whole name on initial load (with delay)
    setTimeout(() => {
      letters.forEach((letter, index) => {
        setTimeout(() => {
          letter.classList.add('pressed');
          letterStates.set(letter, true);
          keyDownSoundPool.play(0.3);
          
          setTimeout(() => {
            letter.classList.remove('pressed');
            letterStates.set(letter, false);
            keyUpSoundPool.play(0.2);
          }, 150);
        }, index * 100);
      });
    }, 1000);
  });
</script><style>
.animated-name {
  display: flex;
  margin-bottom: 1rem;
  padding: 0.5rem 0;
}

.letter {
  font-size: 5rem;
  font-weight: 900;
  letter-spacing: -2px;
  display: inline-block;
  position: relative;
  transition: transform 0.08s cubic-bezier(0.25, 0.46, 0.45, 0.94),
              top 0.08s cubic-bezier(0.25, 0.46, 0.45, 0.94),
              color 0.2s ease;
  cursor: pointer;
  user-select: none;
  top: 0;
  padding: 0 2px;
  transform-origin: center bottom;
  /* No shadow by default */
  text-shadow: none;
}

.letter.pressed {
  transform: scale(0.92);
  top: 6px;
  /* Very slight shadow when pressed */
  text-shadow: 0 2px 4px rgba(0,0,0,0.05);
}

/* Implement shadow using pseudo-element for better control */
.letter:before {
  content: '';
  position: absolute;
  top: calc(100% - 20px);
  left: 1px;
  right: 1px;
  height: 0; /* No height by default */
  background-color: rgba(0,0,0,0.15);
  border-radius: 0 0 6px 6px;
  transition: all 0.08s ease-in;
  filter: blur(2px);
  opacity: 0; /* Invisible by default */
}

.letter.pressed:before {
  height: 4px; /* Small height when pressed */
  opacity: 0.6; /* Slightly visible when pressed */
}
</style>
